//! Lookup tables.
use crate::imp::lab::*;

// Note: Nothing in this file is public â€” `pub` just means `pub(crate)`

/// The "standard" 16 colors, more or less. We don't resolve to these, since
/// they get customized.
pub const ANSI16_TO_RGB: [(u8, u8, u8); 16] = [
    (0x00, 0x00, 0x00), // black
    (0x80, 0x00, 0x00), // red
    (0x00, 0x80, 0x00), // green
    (0x80, 0x80, 0x00), // yellow
    (0x00, 0x00, 0x80), // blue
    (0x80, 0x00, 0x80), // magenta
    (0x00, 0x80, 0x80), // cyan
    (0xc0, 0xc0, 0xc0), // white (err, sorta)
    (0x80, 0x80, 0x80), // bright black
    (0xff, 0x00, 0x00), // bright red
    (0x00, 0xff, 0x00), // bright green
    (0xff, 0xff, 0x00), // bright yellow
    (0x00, 0x00, 0xff), // bright blue
    (0xff, 0x00, 0xff), // bright magenta
    (0x00, 0xff, 0xff), // bright cyan
    (0xff, 0xff, 0xff), // bright white
];

pub const GREY_TO_ANSI256: [u8; 256] = [
    16, 16, 16, 16, 16, 232, 232, 232, 232, 232, 232, 232, 232, 232, 233, 233, 233, 233, 233, 233,
    233, 233, 233, 233, 234, 234, 234, 234, 234, 234, 234, 234, 234, 235, 235, 235, 235, 235, 235,
    235, 235, 235, 235, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 237, 237, 237, 237, 237,
    237, 237, 237, 237, 237, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 239, 239, 239, 239,
    239, 239, 239, 239, 239, 239, 240, 240, 240, 240, 240, 240, 240, 240, 240, 59, 59, 59, 59, 59,
    241, 241, 241, 241, 241, 241, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 243, 243, 243,
    243, 243, 243, 243, 243, 243, 243, 244, 244, 244, 244, 244, 244, 244, 244, 244, 102, 102, 102,
    102, 102, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 247,
    247, 247, 247, 247, 247, 247, 247, 247, 247, 248, 248, 248, 248, 248, 248, 248, 248, 248, 145,
    145, 145, 145, 145, 249, 249, 249, 249, 249, 249, 250, 250, 250, 250, 250, 250, 250, 250, 250,
    250, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 252, 252, 252, 252, 252, 252, 252, 252,
    252, 188, 188, 188, 188, 188, 253, 253, 253, 253, 253, 253, 254, 254, 254, 254, 254, 254, 254,
    254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 231, 231,
    231, 231, 231, 231, 231, 231, 231,
];

pub const ANSI256_RGB: [(u8, u8, u8); 240] = [
    // 0..15 - "named" ansi colors. Note that these are typically customizable,
    // so we never return them for closest color queries.
    // (0x00, 0x00, 0x00),
    // (0x80, 0x00, 0x00),
    // (0x00, 0x80, 0x00),
    // (0x80, 0x80, 0x00),
    // (0x00, 0x00, 0x80),
    // (0x80, 0x00, 0x80),
    // (0x00, 0x80, 0x80),
    // (0xc0, 0xc0, 0xc0),
    // (0x80, 0x80, 0x80),
    // (0xff, 0x00, 0x00),
    // (0x00, 0xff, 0x00),
    // (0xff, 0xff, 0x00),
    // (0x00, 0x00, 0xff),
    // (0xff, 0x00, 0xff),
    // (0x00, 0xff, 0xff),
    // (0xff, 0xff, 0xff),
    // 16..232 - 6x6x6 color cube
    (0x00, 0x00, 0x00), // 16
    (0x00, 0x00, 0x5f), // 17
    (0x00, 0x00, 0x87), // 18
    (0x00, 0x00, 0xaf), // 19
    (0x00, 0x00, 0xd7), // 20
    (0x00, 0x00, 0xff), // 21
    (0x00, 0x5f, 0x00), // 22
    (0x00, 0x5f, 0x5f), // 23
    (0x00, 0x5f, 0x87), // 24
    (0x00, 0x5f, 0xaf), // 25
    (0x00, 0x5f, 0xd7), // 26
    (0x00, 0x5f, 0xff), // 27
    (0x00, 0x87, 0x00), // 28
    (0x00, 0x87, 0x5f), // 29
    (0x00, 0x87, 0x87), // 30
    (0x00, 0x87, 0xaf), // 31
    (0x00, 0x87, 0xd7), // 32
    (0x00, 0x87, 0xff), // 33
    (0x00, 0xaf, 0x00), // 34
    (0x00, 0xaf, 0x5f), // 35
    (0x00, 0xaf, 0x87), // 36
    (0x00, 0xaf, 0xaf), // 37
    (0x00, 0xaf, 0xd7), // 38
    (0x00, 0xaf, 0xff), // 39
    (0x00, 0xd7, 0x00), // 40
    (0x00, 0xd7, 0x5f), // 41
    (0x00, 0xd7, 0x87), // 42
    (0x00, 0xd7, 0xaf), // 43
    (0x00, 0xd7, 0xd7), // 44
    (0x00, 0xd7, 0xff), // 45
    (0x00, 0xff, 0x00), // 46
    (0x00, 0xff, 0x5f), // 47
    (0x00, 0xff, 0x87), // 48
    (0x00, 0xff, 0xaf), // 49
    (0x00, 0xff, 0xd7), // 50
    (0x00, 0xff, 0xff), // 51
    (0x5f, 0x00, 0x00), // 52
    (0x5f, 0x00, 0x5f), // 53
    (0x5f, 0x00, 0x87), // 54
    (0x5f, 0x00, 0xaf), // 55
    (0x5f, 0x00, 0xd7), // 56
    (0x5f, 0x00, 0xff), // 57
    (0x5f, 0x5f, 0x00), // 58
    (0x5f, 0x5f, 0x5f), // 59
    (0x5f, 0x5f, 0x87), // 60
    (0x5f, 0x5f, 0xaf), // 61
    (0x5f, 0x5f, 0xd7), // 62
    (0x5f, 0x5f, 0xff), // 63
    (0x5f, 0x87, 0x00), // 64
    (0x5f, 0x87, 0x5f), // 65
    (0x5f, 0x87, 0x87), // 66
    (0x5f, 0x87, 0xaf), // 67
    (0x5f, 0x87, 0xd7), // 68
    (0x5f, 0x87, 0xff), // 69
    (0x5f, 0xaf, 0x00), // 70
    (0x5f, 0xaf, 0x5f), // 71
    (0x5f, 0xaf, 0x87), // 72
    (0x5f, 0xaf, 0xaf), // 73
    (0x5f, 0xaf, 0xd7), // 74
    (0x5f, 0xaf, 0xff), // 75
    (0x5f, 0xd7, 0x00), // 76
    (0x5f, 0xd7, 0x5f), // 77
    (0x5f, 0xd7, 0x87), // 78
    (0x5f, 0xd7, 0xaf), // 79
    (0x5f, 0xd7, 0xd7), // 80
    (0x5f, 0xd7, 0xff), // 81
    (0x5f, 0xff, 0x00), // 82
    (0x5f, 0xff, 0x5f), // 83
    (0x5f, 0xff, 0x87), // 84
    (0x5f, 0xff, 0xaf), // 85
    (0x5f, 0xff, 0xd7), // 86
    (0x5f, 0xff, 0xff), // 87
    (0x87, 0x00, 0x00), // 88
    (0x87, 0x00, 0x5f), // 89
    (0x87, 0x00, 0x87), // 90
    (0x87, 0x00, 0xaf), // 91
    (0x87, 0x00, 0xd7), // 92
    (0x87, 0x00, 0xff), // 93
    (0x87, 0x5f, 0x00), // 94
    (0x87, 0x5f, 0x5f), // 95
    (0x87, 0x5f, 0x87), // 96
    (0x87, 0x5f, 0xaf), // 97
    (0x87, 0x5f, 0xd7), // 98
    (0x87, 0x5f, 0xff), // 99
    (0x87, 0x87, 0x00), // 100
    (0x87, 0x87, 0x5f), // 101
    (0x87, 0x87, 0x87), // 102
    (0x87, 0x87, 0xaf), // 103
    (0x87, 0x87, 0xd7), // 104
    (0x87, 0x87, 0xff), // 105
    (0x87, 0xaf, 0x00), // 106
    (0x87, 0xaf, 0x5f), // 107
    (0x87, 0xaf, 0x87), // 108
    (0x87, 0xaf, 0xaf), // 109
    (0x87, 0xaf, 0xd7), // 110
    (0x87, 0xaf, 0xff), // 111
    (0x87, 0xd7, 0x00), // 112
    (0x87, 0xd7, 0x5f), // 113
    (0x87, 0xd7, 0x87), // 114
    (0x87, 0xd7, 0xaf), // 115
    (0x87, 0xd7, 0xd7), // 116
    (0x87, 0xd7, 0xff), // 117
    (0x87, 0xff, 0x00), // 118
    (0x87, 0xff, 0x5f), // 119
    (0x87, 0xff, 0x87), // 120
    (0x87, 0xff, 0xaf), // 121
    (0x87, 0xff, 0xd7), // 122
    (0x87, 0xff, 0xff), // 123
    (0xaf, 0x00, 0x00), // 124
    (0xaf, 0x00, 0x5f), // 125
    (0xaf, 0x00, 0x87), // 126
    (0xaf, 0x00, 0xaf), // 127
    (0xaf, 0x00, 0xd7), // 128
    (0xaf, 0x00, 0xff), // 129
    (0xaf, 0x5f, 0x00), // 130
    (0xaf, 0x5f, 0x5f), // 131
    (0xaf, 0x5f, 0x87), // 132
    (0xaf, 0x5f, 0xaf), // 133
    (0xaf, 0x5f, 0xd7), // 134
    (0xaf, 0x5f, 0xff), // 135
    (0xaf, 0x87, 0x00), // 136
    (0xaf, 0x87, 0x5f), // 137
    (0xaf, 0x87, 0x87), // 138
    (0xaf, 0x87, 0xaf), // 139
    (0xaf, 0x87, 0xd7), // 140
    (0xaf, 0x87, 0xff), // 141
    (0xaf, 0xaf, 0x00), // 142
    (0xaf, 0xaf, 0x5f), // 143
    (0xaf, 0xaf, 0x87), // 144
    (0xaf, 0xaf, 0xaf), // 145
    (0xaf, 0xaf, 0xd7), // 146
    (0xaf, 0xaf, 0xff), // 147
    (0xaf, 0xd7, 0x00), // 148
    (0xaf, 0xd7, 0x5f), // 149
    (0xaf, 0xd7, 0x87), // 150
    (0xaf, 0xd7, 0xaf), // 151
    (0xaf, 0xd7, 0xd7), // 152
    (0xaf, 0xd7, 0xff), // 153
    (0xaf, 0xff, 0x00), // 154
    (0xaf, 0xff, 0x5f), // 155
    (0xaf, 0xff, 0x87), // 156
    (0xaf, 0xff, 0xaf), // 157
    (0xaf, 0xff, 0xd7), // 158
    (0xaf, 0xff, 0xff), // 159
    (0xd7, 0x00, 0x00), // 160
    (0xd7, 0x00, 0x5f), // 161
    (0xd7, 0x00, 0x87), // 162
    (0xd7, 0x00, 0xaf), // 163
    (0xd7, 0x00, 0xd7), // 164
    (0xd7, 0x00, 0xff), // 165
    (0xd7, 0x5f, 0x00), // 166
    (0xd7, 0x5f, 0x5f), // 167
    (0xd7, 0x5f, 0x87), // 168
    (0xd7, 0x5f, 0xaf), // 169
    (0xd7, 0x5f, 0xd7), // 170
    (0xd7, 0x5f, 0xff), // 171
    (0xd7, 0x87, 0x00), // 172
    (0xd7, 0x87, 0x5f), // 173
    (0xd7, 0x87, 0x87), // 174
    (0xd7, 0x87, 0xaf), // 175
    (0xd7, 0x87, 0xd7), // 176
    (0xd7, 0x87, 0xff), // 177
    (0xd7, 0xaf, 0x00), // 178
    (0xd7, 0xaf, 0x5f), // 179
    (0xd7, 0xaf, 0x87), // 180
    (0xd7, 0xaf, 0xaf), // 181
    (0xd7, 0xaf, 0xd7), // 182
    (0xd7, 0xaf, 0xff), // 183
    (0xd7, 0xd7, 0x00), // 184
    (0xd7, 0xd7, 0x5f), // 185
    (0xd7, 0xd7, 0x87), // 186
    (0xd7, 0xd7, 0xaf), // 187
    (0xd7, 0xd7, 0xd7), // 188
    (0xd7, 0xd7, 0xff), // 189
    (0xd7, 0xff, 0x00), // 190
    (0xd7, 0xff, 0x5f), // 191
    (0xd7, 0xff, 0x87), // 192
    (0xd7, 0xff, 0xaf), // 193
    (0xd7, 0xff, 0xd7), // 194
    (0xd7, 0xff, 0xff), // 195
    (0xff, 0x00, 0x00), // 196
    (0xff, 0x00, 0x5f), // 197
    (0xff, 0x00, 0x87), // 198
    (0xff, 0x00, 0xaf), // 199
    (0xff, 0x00, 0xd7), // 200
    (0xff, 0x00, 0xff), // 201
    (0xff, 0x5f, 0x00), // 202
    (0xff, 0x5f, 0x5f), // 203
    (0xff, 0x5f, 0x87), // 204
    (0xff, 0x5f, 0xaf), // 205
    (0xff, 0x5f, 0xd7), // 206
    (0xff, 0x5f, 0xff), // 207
    (0xff, 0x87, 0x00), // 208
    (0xff, 0x87, 0x5f), // 209
    (0xff, 0x87, 0x87), // 210
    (0xff, 0x87, 0xaf), // 211
    (0xff, 0x87, 0xd7), // 212
    (0xff, 0x87, 0xff), // 213
    (0xff, 0xaf, 0x00), // 214
    (0xff, 0xaf, 0x5f), // 215
    (0xff, 0xaf, 0x87), // 216
    (0xff, 0xaf, 0xaf), // 217
    (0xff, 0xaf, 0xd7), // 218
    (0xff, 0xaf, 0xff), // 219
    (0xff, 0xd7, 0x00), // 220
    (0xff, 0xd7, 0x5f), // 221
    (0xff, 0xd7, 0x87), // 222
    (0xff, 0xd7, 0xaf), // 223
    (0xff, 0xd7, 0xd7), // 224
    (0xff, 0xd7, 0xff), // 225
    (0xff, 0xff, 0x00), // 226
    (0xff, 0xff, 0x5f), // 227
    (0xff, 0xff, 0x87), // 228
    (0xff, 0xff, 0xaf), // 229
    (0xff, 0xff, 0xd7), // 230
    (0xff, 0xff, 0xff), // 231
    // 232..256 - greyscale ramp
    (0x08, 0x08, 0x08), // 232
    (0x12, 0x12, 0x12), // 233
    (0x1c, 0x1c, 0x1c), // 234
    (0x26, 0x26, 0x26), // 235
    (0x30, 0x30, 0x30), // 236
    (0x3a, 0x3a, 0x3a), // 237
    (0x44, 0x44, 0x44), // 238
    (0x4e, 0x4e, 0x4e), // 239
    (0x58, 0x58, 0x58), // 240
    (0x62, 0x62, 0x62), // 241
    (0x6c, 0x6c, 0x6c), // 242
    (0x76, 0x76, 0x76), // 243
    (0x80, 0x80, 0x80), // 244
    (0x8a, 0x8a, 0x8a), // 245
    (0x94, 0x94, 0x94), // 246
    (0x9e, 0x9e, 0x9e), // 247
    (0xa8, 0xa8, 0xa8), // 248
    (0xb2, 0xb2, 0xb2), // 249
    (0xbc, 0xbc, 0xbc), // 250
    (0xc6, 0xc6, 0xc6), // 251
    (0xd0, 0xd0, 0xd0), // 252
    (0xda, 0xda, 0xda), // 253
    (0xe4, 0xe4, 0xe4), // 254
    (0xee, 0xee, 0xee), // 255
];

#[cfg(feature = "88color")]
pub const GREY_TO_ANSI88: [u8; 256] = [
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
    80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81,
    81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
    81, 81, 81, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
    82, 82, 82, 82, 82, 82, 82, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
    37, 37, 37, 37, 37, 37, 37, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
    84, 84, 84, 84, 84, 84, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
    85, 85, 85, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 86, 86, 86, 86, 86, 86, 86, 86, 86,
    86, 86, 86, 86, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,
    87, 87, 87, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
];

#[cfg(feature = "88color")]
pub const ANSI88_RGB: [(u8, u8, u8); 72] = [
    // 0..15 - "named" ansi colors. Note that these are typically customizable,
    // so we never return them for closest color queries.
    // TODO: these don't need to be in this table
    // (0x00, 0x00, 0x00),
    // (0x80, 0x00, 0x00),
    // (0x00, 0x80, 0x00),
    // (0x80, 0x80, 0x00),
    // (0x00, 0x00, 0x80),
    // (0x80, 0x00, 0x80),
    // (0x00, 0x80, 0x80),
    // (0xc0, 0xc0, 0xc0),
    // (0x80, 0x80, 0x80),
    // (0xff, 0x00, 0x00),
    // (0x00, 0xff, 0x00),
    // (0xff, 0xff, 0x00),
    // (0x00, 0x00, 0xff),
    // (0xff, 0x00, 0xff),
    // (0x00, 0xff, 0xff),
    // (0xff, 0xff, 0xff),
    // 16..80 - 4x4x4 color cube
    (0x00, 0x00, 0x00), // 16
    (0x00, 0x00, 0x8b), // 17
    (0x00, 0x00, 0xcd), // 18
    (0x00, 0x00, 0xff), // 19
    (0x00, 0x8b, 0x00), // 20
    (0x00, 0x8b, 0x8b), // 21
    (0x00, 0x8b, 0xcd), // 22
    (0x00, 0x8b, 0xff), // 23
    (0x00, 0xcd, 0x00), // 24
    (0x00, 0xcd, 0x8b), // 25
    (0x00, 0xcd, 0xcd), // 26
    (0x00, 0xcd, 0xff), // 27
    (0x00, 0xff, 0x00), // 28
    (0x00, 0xff, 0x8b), // 29
    (0x00, 0xff, 0xcd), // 30
    (0x00, 0xff, 0xff), // 31
    (0x8b, 0x00, 0x00), // 32
    (0x8b, 0x00, 0x8b), // 33
    (0x8b, 0x00, 0xcd), // 34
    (0x8b, 0x00, 0xff), // 35
    (0x8b, 0x8b, 0x00), // 36
    (0x8b, 0x8b, 0x8b), // 37
    (0x8b, 0x8b, 0xcd), // 38
    (0x8b, 0x8b, 0xff), // 39
    (0x8b, 0xcd, 0x00), // 40
    (0x8b, 0xcd, 0x8b), // 41
    (0x8b, 0xcd, 0xcd), // 42
    (0x8b, 0xcd, 0xff), // 43
    (0x8b, 0xff, 0x00), // 44
    (0x8b, 0xff, 0x8b), // 45
    (0x8b, 0xff, 0xcd), // 46
    (0x8b, 0xff, 0xff), // 47
    (0xcd, 0x00, 0x00), // 48
    (0xcd, 0x00, 0x8b), // 49
    (0xcd, 0x00, 0xcd), // 50
    (0xcd, 0x00, 0xff), // 51
    (0xcd, 0x8b, 0x00), // 52
    (0xcd, 0x8b, 0x8b), // 53
    (0xcd, 0x8b, 0xcd), // 54
    (0xcd, 0x8b, 0xff), // 55
    (0xcd, 0xcd, 0x00), // 56
    (0xcd, 0xcd, 0x8b), // 57
    (0xcd, 0xcd, 0xcd), // 58
    (0xcd, 0xcd, 0xff), // 59
    (0xcd, 0xff, 0x00), // 60
    (0xcd, 0xff, 0x8b), // 61
    (0xcd, 0xff, 0xcd), // 62
    (0xcd, 0xff, 0xff), // 63
    (0xff, 0x00, 0x00), // 64
    (0xff, 0x00, 0x8b), // 65
    (0xff, 0x00, 0xcd), // 66
    (0xff, 0x00, 0xff), // 67
    (0xff, 0x8b, 0x00), // 68
    (0xff, 0x8b, 0x8b), // 69
    (0xff, 0x8b, 0xcd), // 70
    (0xff, 0x8b, 0xff), // 71
    (0xff, 0xcd, 0x00), // 72
    (0xff, 0xcd, 0x8b), // 73
    (0xff, 0xcd, 0xcd), // 74
    (0xff, 0xcd, 0xff), // 75
    (0xff, 0xff, 0x00), // 76
    (0xff, 0xff, 0x8b), // 77
    (0xff, 0xff, 0xcd), // 78
    (0xff, 0xff, 0xff), // 79
    // greyscale ramp
    (0x2e, 0x2e, 0x2e), // 80
    (0x5c, 0x5c, 0x5c), // 81
    (0x73, 0x73, 0x73), // 82
    (0x8b, 0x8b, 0x8b), // 83
    (0xa2, 0xa2, 0xa2), // 84
    (0xb9, 0xb9, 0xb9), // 85
    (0xd0, 0xd0, 0xd0), // 86
    (0xe7, 0xe7, 0xe7), // 87
];

macro_rules! gen_lab_tables {
    ($(#[$m1:meta])* $name1:ident, $(#[$m2:meta])* $name2:ident, $size:expr, [$(
        ($l0:expr, $a0:expr, $b0:expr),
        ($l1:expr, $a1:expr, $b1:expr),
        ($l2:expr, $a2:expr, $b2:expr),
        ($l3:expr, $a3:expr, $b3:expr),
        ($l4:expr, $a4:expr, $b4:expr),
        ($l5:expr, $a5:expr, $b5:expr),
        ($l6:expr, $a6:expr, $b6:expr),
        ($l7:expr, $a7:expr, $b7:expr),
    )+]) => {
        $(#[$m1])*
        pub(crate) static $name1: [Lab; $size] = [$(
            Lab { l: $l0, a: $a0, b: $b0 },
            Lab { l: $l1, a: $a1, b: $b1 },
            Lab { l: $l2, a: $a2, b: $b2 },
            Lab { l: $l3, a: $a3, b: $b3 },
            Lab { l: $l4, a: $a4, b: $b4 },
            Lab { l: $l5, a: $a5, b: $b5 },
            Lab { l: $l6, a: $a6, b: $b6 },
            Lab { l: $l7, a: $a7, b: $b7 },
        )+];

        $(#[$m2])*
        #[cfg(any(
            all(
                feature = "simd",
                any(target_arch = "x86_64", target_arch = "x86"),
                target_feature = "sse2",
                not(miri),
            ),
            all(
                feature = "unstable-portable-simd",
                not(any(target_arch = "x86_64", target_arch = "x86")),
            ),
            all(
                feature = "simd",
                target_arch = "aarch64",
                target_feature = "neon",
                not(miri),
            )
        ))]
        pub(crate) static $name2: [Lab8; $size / 8] = [$(
            Lab8 {
                l: SimdRow([$l0, $l1, $l2, $l3, $l4, $l5, $l6, $l7]),
                a: SimdRow([$a0, $a1, $a2, $a3, $a4, $a5, $a6, $a7]),
                b: SimdRow([$b0, $b1, $b2, $b3, $b4, $b5, $b6, $b7]),
            },
        )+];
    };
}

gen_lab_tables! {
    LAB_PALETTE_ANSI256,
    LAB_ROWS_ANSI256,
    240,
    [
        (0.0, 0.0, 0.0),
        (0.21945143, -0.01575777, -0.15124606),
        (0.28178954, -0.020233974, -0.19420952),
        (0.34082618, -0.0244731, -0.23489758),
        (0.3973963, -0.028535187, -0.2738858),
        (0.4520137, -0.032456964, -0.31152815),
        (0.42065406, -0.11355172, 0.087146014),
        (0.4395688, -0.07255453, -0.019127697),
        (0.45908442, -0.05526048, -0.08179703),
        (0.4849069, -0.04412508, -0.14114544),
        (0.5158243, -0.038223833, -0.19581121),
        (0.5505866, -0.036017746, -0.24609107),
        (0.54014647, -0.14580768, 0.111901045),
        (0.55183345, -0.11317666, 0.03273973),
        (0.5644343, -0.09316474, -0.024561167),
        (0.58191586, -0.07614604, -0.08368099),
        (0.6039327, -0.06338224, -0.14104792),
        (0.6299223, -0.05471745, -0.19538587),
        (0.6533105, -0.17635529, 0.13534495),
        (0.6613503, -0.15079442, 0.075170875),
        (0.67017204, -0.1316404, 0.025488436),
        (0.68268675, -0.112683296, -0.029706955),
        (0.69887954, -0.09604159, -0.08616805),
        (0.7185603, -0.082555294, -0.14163136),
        (0.76174664, -0.20562676, 0.15780947),
        (0.76767623, -0.18535519, 0.11082989),
        (0.77423394, -0.16822812, 0.06857163),
        (0.78364235, -0.14951989, 0.018766284),
        (0.7959987, -0.13138643, -0.03463763),
        (0.8112802, -0.11511955, -0.08900452),
        (0.8664396, -0.2338874, 0.1794985),
        (0.8710288, -0.21750051, 0.14186257),
        (0.876124, -0.20255691, 0.10602385),
        (0.88347876, -0.1850791, 0.06181562),
        (0.8932213, -0.16691509, 0.012483656),
        (0.90539926, -0.1494439, -0.039398134),
        (0.3048706, 0.1091704, 0.061098024),
        (0.34066075, 0.13330114, -0.08212477),
        (0.3728961, 0.12249705, -0.14249241),
        (0.4112718, 0.104753375, -0.19547123),
        (0.45331943, 0.08530313, -0.24302793),
        (0.49744356, 0.066738576, -0.2867549),
        (0.46995294, -0.03464946, 0.09640509),
        (0.48549724, 0.000000014901161, 0.000000029802322),
        (0.50186557, 0.015191138, -0.06144744),
        (0.5239784, 0.024147123, -0.12134954),
        (0.55102885, 0.027281255, -0.177434),
        (0.5820608, 0.026062697, -0.2294375),
        (0.5720238, -0.090493426, 0.11784816),
        (0.58255553, -0.061045274, 0.04348156),
        (0.5939752, -0.042566955, -0.012224644),
        (0.60992646, -0.026922941, -0.070721805),
        (0.63017714, -0.015574932, -0.12817168),
        (0.6542841, -0.008513957, -0.1830216),
        (0.6757256, -0.1359734, 0.13951313),
        (0.683283, -0.11204216, 0.081787765),
        (0.6915908, -0.09388909, 0.033340693),
        (0.7034066, -0.075856745, -0.02105254),
        (0.7187448, -0.060090452, -0.077144146),
        (0.7374562, -0.047498286, -0.13257247),
        (0.7784736, -0.17489707, 0.16091448),
        (0.78417027, -0.15551075, 0.11526781),
        (0.79047513, -0.13902286, 0.07386321),
        (0.79953027, -0.12094754, 0.024752855),
        (0.81143993, -0.10341141, -0.028189182),
        (0.8261948, -0.08772239, -0.08231586),
        (0.87947434, -0.20967159, 0.1819157),
        (0.88393855, -0.19379553, 0.14505136),
        (0.8888966, -0.17926407, 0.109787226),
        (0.8960568, -0.16222385, 0.06611782),
        (0.90554816, -0.1444853, 0.017212093),
        (0.9174228, -0.12742159, -0.034377933),
        (0.39147317, 0.14018172, 0.078453705),
        (0.4145116, 0.1703483, -0.042265296),
        (0.43742996, 0.17116722, -0.10545346),
        (0.46677762, 0.16226044, -0.16319314),
        (0.5008869, 0.1473515, -0.21550325),
        (0.53832316, 0.12967274, -0.26336262),
        (0.51425487, 0.018674493, 0.104892075),
        (0.5274639, 0.0496756, 0.01707694),
        (0.5415629, 0.06461343, -0.042637587),
        (0.5608929, 0.07386151, -0.102464914),
        (0.5849188, 0.0771327, -0.159426),
        (0.61291206, 0.0755021, -0.21275038),
        (0.6034494, -0.04449226, 0.123790234),
        (0.6130028, -0.017503172, 0.053987086),
        (0.6234093, 0.0, 0.000000059604645),
        (0.63802856, 0.015011221, -0.057689905),
        (0.6567161, 0.025852472, -0.11504513),
        (0.67912704, 0.03232506, -0.17026287),
        (0.6988905, -0.09849526, 0.14385992),
        (0.70599484, -0.07601568, 0.08859268),
        (0.71381783, -0.058706045, 0.041449428),
        (0.72497016, -0.041380167, -0.012053847),
        (0.7394914, -0.026206434, -0.067693174),
        (0.75726813, -0.014172643, -0.12302011),
        (0.7962169, -0.14456579, 0.16422889),
        (0.801682, -0.12603042, 0.11996454),
        (0.80773467, -0.11014545, 0.07946664),
        (0.81643677, -0.09264496, 0.03111136),
        (0.8278984, -0.07562256, -0.021313667),
        (0.842123, -0.06040287, -0.075155735),
        (0.8935169, -0.18487233, 0.18453145),
        (0.8978524, -0.16951057, 0.14848405),
        (0.9026691, -0.15539065, 0.11383593),
        (0.9096284, -0.13877949, 0.07075125),
        (0.91886026, -0.121448606, 0.022314906),
        (0.93042046, -0.10476264, -0.028947413),
        (0.47348917, 0.16955064, 0.09489027),
        (0.48961607, 0.19914411, -0.0056277215),
        (0.50647354, 0.20740664, -0.06772506),
        (0.5290742, 0.20702776, -0.12754661),
        (0.5565127, 0.19929409, -0.18318456),
        (0.5877834, 0.18646017, -0.23460689),
        (0.5673052, 0.06971961, 0.115181595),
        (0.5783239, 0.097317025, 0.036917865),
        (0.59022695, 0.112386584, -0.020126611),
        (0.6067754, 0.12283531, -0.07919431),
        (0.6276702, 0.1276092, -0.136657),
        (0.6524067, 0.12718725, -0.19118196),
        (0.64375144, 0.005603671, 0.13149554),
        (0.6522333, 0.030020624, 0.06721881),
        (0.6615167, 0.04664123, 0.015582085),
        (0.6746394, 0.061347187, -0.040827215),
        (0.6915419, 0.072224885, -0.09781289),
        (0.71198195, 0.07878995, -0.15329331),
        (0.72987574, -0.053813457, 0.14972496),
        (0.7364349, -0.033008248, 0.09760895),
        (0.74367183, -0.016630739, 0.052231967),
        (0.7540173, 0.000000029802322, 0.0),
        (0.76753694, 0.014700472, -0.054931283),
        (0.78415823, 0.026378334, -0.110021114),
        (0.8205774, -0.10619977, 0.16880968),
        (0.8257473, -0.08871445, 0.12638414),
        (0.83147794, -0.07356131, 0.08712679),
        (0.8397276, -0.05673048, 0.039831877),
        (0.85061306, -0.040264696, -0.01184237),
        (0.8641523, -0.025509566, -0.06524694),
        (0.9131206, -0.15226507, 0.18820173),
        (0.91728586, -0.13756642, 0.15326786),
        (0.9219153, -0.12397346, 0.119472444),
        (0.9286084, -0.10790333, 0.077209115),
        (0.93749535, -0.09106943, 0.029443502),
        (0.94863683, -0.07482481, -0.021340072),
        (0.5520787, 0.19769266, 0.11064011),
        (0.5640697, 0.22454189, 0.026858658),
        (0.57693666, 0.23668107, -0.0318335),
        (0.59468347, 0.24246895, -0.09144944),
        (0.6168897, 0.24138993, -0.14871672),
        (0.6429402, 0.23445228, -0.20262575),
        (0.6257253, 0.11587842, 0.12661526),
        (0.6348868, 0.14033543, 0.057751685),
        (0.64487666, 0.15544844, 0.0041345954),
        (0.65892786, 0.1672869, -0.053379238),
        (0.6769157, 0.17418364, -0.110719025),
        (0.69852346, 0.17599791, -0.16603184),
        (0.6907873, 0.05503133, 0.14057681),
        (0.6982251, 0.07696596, 0.08222404),
        (0.7064011, 0.09277284, 0.03344363),
        (0.7180268, 0.107402384, -0.021185815),
        (0.7331132, 0.118757874, -0.07741469),
        (0.7515105, 0.1260531, -0.13290465),
        (0.7675407, -0.006118208, 0.15691769),
        (0.7735164, 0.012948602, 0.10840064),
        (0.7801225, 0.028380692, 0.06517321),
        (0.78959334, 0.044388056, 0.014583707),
        (0.80201817, 0.05880031, -0.039344966),
        (0.8173637, 0.07041523, -0.09399748),
        (0.85102016, -0.06274551, 0.17457634),
        (0.85585356, -0.046420157, 0.13434619),
        (0.86121625, -0.0320659, 0.09662074),
        (0.86894715, -0.015935779, 0.050677896),
        (0.87916875, 0.000000059604645, 0.000000059604645),
        (0.8919143, 0.014378905, -0.05278641),
        (0.9380859, -0.113731384, 0.19290358),
        (0.9420488, -0.09980062, 0.15934044),
        (0.94645524, -0.08681399, 0.12661463),
        (0.9528308, -0.07135442, 0.0854013),
        (0.9613051, -0.05506113, 0.038511813),
        (0.9719444, -0.039266795, -0.011629283),
        (0.6279554, 0.22486295, 0.1258463),
        (0.637274, 0.2485399, 0.05552101),
        (0.6474213, 0.2622939, 0.0013148785),
        (0.6616679, 0.27199948, -0.05650395),
        (0.67986554, 0.27608937, -0.11391932),
        (0.7016738, 0.27456632, -0.16915613),
        (0.68721557, 0.15724804, 0.1387254),
        (0.6948738, 0.17885262, 0.078464955),
        (0.7032815, 0.19371217, 0.028722703),
        (0.71521485, 0.20665306, -0.02653575),
        (0.730664, 0.21563461, -0.08306438),
        (0.74945384, 0.21999735, -0.13860208),
        (0.74263614, 0.10158342, 0.15066692),
        (0.74912506, 0.1212146, 0.09817162),
        (0.75628394, 0.13620797, 0.052571774),
        (0.76651573, 0.15080526, 0.00016850233),
        (0.77988285, 0.16282454, -0.05487293),
        (0.7963107, 0.17121884, -0.11002153),
        (0.81059945, 0.041587323, 0.16520673),
        (0.81599617, 0.058954954, 0.12048274),
        (0.82197315, 0.07345533, 0.07967597),
        (0.8305656, 0.08889663, 0.03105414),
        (0.8418806, 0.10316554, -0.02156657),
        (0.8559195, 0.11496708, -0.07553446),
        (0.886771, -0.016925097, 0.18139815),
        (0.8912491, -0.001794666, 0.14359498),
        (0.8962219, 0.011737704, 0.107628465),
        (0.9034013, 0.027169466, 0.06329459),
        (0.9129136, 0.042629868, 0.013854206),
        (0.92480606, 0.056749493, -0.038115144),
        (0.9679827, -0.07136908, 0.19856972),
        (0.97172195, -0.058264583, 0.16657531),
        (0.9758818, -0.04592961, 0.13510126),
        (0.98190516, -0.03111574, 0.095143616),
        (0.98992103, -0.015371084, 0.049328506),
        (1.0, 0.0, 0.000000059604645),
        (0.13440923, 0.0000000037252903, 0.000000007450581),
        (0.18220371, -0.000000007450581, 0.0),
        (0.22644986, 0.000000022351742, 0.0),
        (0.26861826, 0.000000044703484, 0.0),
        (0.30918562, 0.000000014901161, 0.000000029802322),
        (0.34845966, -0.000000029802322, 0.0),
        (0.38665435, 0.0, 0.0),
        (0.4239265, -0.000000029802322, 0.0),
        (0.46039563, -0.00000008940697, 0.000000029802322),
        (0.49615562, -0.000000029802322, 0.000000029802322),
        (0.5312818, 0.00000008940697, 0.000000029802322),
        (0.56583637, -0.000000029802322, 0.000000029802322),
        (0.5998708, 0.000000029802322, 0.000000029802322),
        (0.633429, 0.0, 0.0),
        (0.6665481, 0.00000008940697, -0.000000059604645),
        (0.6992607, -0.000000059604645, 0.000000059604645),
        (0.731595, -0.000000059604645, 0.0),
        (0.76357573, -0.000000029802322, 0.000000059604645),
        (0.7952249, 0.000000029802322, 0.000000059604645),
        (0.8265622, 0.00000008940697, 0.0),
        (0.8576052, 0.00000008940697, 0.0),
        (0.88836974, 0.0, 0.0),
        (0.9188701, -0.000000029802322, 0.000000059604645),
        (0.94911927, -0.000000059604645, 0.000000059604645),
    ]
}

gen_lab_tables! {
    #[cfg(feature = "88color")]
    LAB_PALETTE_ANSI88,
    #[cfg(feature = "88color")]
    LAB_ROWS_ANSI88,
    72,
    [
        (0.0, 0.0, 0.0),
        (0.2878243, -0.0206673, -0.19836867),
        (0.3834533, -0.027533978, -0.26427627),
        (0.4520137, -0.032456964, -0.31152815),
        (0.5517141, -0.14893016, 0.11429742),
        (0.5765221, -0.09515983, -0.025087237),
        (0.6075066, -0.06933743, -0.1213634),
        (0.63848037, -0.05717066, -0.19005519),
        (0.73502004, -0.19841206, 0.15227255),
        (0.7492824, -0.15741602, 0.053507447),
        (0.7680703, -0.12677658, -0.03342235),
        (0.7878944, -0.10672426, -0.10192394),
        (0.8664396, -0.2338874, 0.1794985),
        (0.87675506, -0.20089024, 0.10192311),
        (0.89055794, -0.1714358, 0.025142074),
        (0.90539926, -0.1494439, -0.039398134),
        (0.39985693, 0.14318381, 0.0801339),
        (0.4467979, 0.17483282, -0.10771179),
        (0.49743858, 0.15699005, -0.19971588),
        (0.5429364, 0.13571924, -0.26069143),
        (0.61637276, -0.045444936, 0.12644124),
        (0.63676006, 0.0, 0.0),
        (0.6627997, 0.022596955, -0.09467232),
        (0.6893908, 0.032160163, -0.16419017),
        (0.7741168, -0.12998083, 0.15956119),
        (0.78709555, -0.092683345, 0.066360354),
        (0.80428064, -0.06422183, -0.018299103),
        (0.8225205, -0.04565239, -0.08609772),
        (0.895228, -0.18193612, 0.18485105),
        (0.9049427, -0.15098754, 0.11035454),
        (0.9179676, -0.123022854, 0.03538412),
        (0.9320073, -0.10207316, -0.02828455),
        (0.5327085, 0.19075644, 0.10675821),
        (0.5609408, 0.23058328, -0.04661995),
        (0.59524554, 0.23292077, -0.14349887),
        (0.6287456, 0.22325638, -0.21081972),
        (0.68600726, 0.036635593, 0.13979837),
        (0.7028026, 0.076487005, 0.02678001),
        (0.7246323, 0.098840415, -0.06490016),
        (0.7473251, 0.10897267, -0.13445961),
        (0.8211613, -0.060544074, 0.16845119),
        (0.8328142, -0.026747257, 0.08169073),
        (0.8483223, 0.000000029802322, 0.0),
        (0.86488146, 0.017706782, -0.06670517),
        (0.9313626, -0.12380466, 0.19163442),
        (0.9403969, -0.09505212, 0.12088007),
        (0.9525355, -0.068587154, 0.04823762),
        (0.9656562, -0.048578918, -0.014245689),
        (0.6279554, 0.22486295, 0.1258463),
        (0.648662, 0.26348913, -0.0043944716),
        (0.674962, 0.2756116, -0.099726796),
        (0.7016738, 0.27456632, -0.16915613),
        (0.74894756, 0.09565355, 0.15202156),
        (0.7632234, 0.13156626, 0.050208032),
        (0.7819947, 0.15428028, -0.037909627),
        (0.80175614, 0.1658248, -0.106785715),
        (0.86715233, -0.00262177, 0.17723686),
        (0.8776923, 0.028367609, 0.0964185),
        (0.8917762, 0.05391258, 0.017800272),
        (0.9068899, 0.07126486, -0.04760754),
        (0.9679827, -0.07136908, 0.19856972),
        (0.9763977, -0.04453373, 0.13144428),
        (0.98772544, -0.01931709, 0.06119448),
        (1.0, 0.0, 0.000000059604645),
        (0.30118382, -0.000000014901161, 0.0),
        (0.4747801, -0.000000044703484, 0.0),
        (0.55552685, 0.00000017881393, -0.000000029802322),
        (0.63676006, 0.0, 0.0),
        (0.71223843, 0.000000029802322, 0.000000059604645),
        (0.78576374, 0.000000059604645, 0.000000059604645),
        (0.8576052, 0.00000008940697, 0.0),
        (0.92797065, -0.000000059604645, 0.000000059604645),
    ]
}

// Returns true if `(r, g, b)` *might* be exactly equal to something in the
// `-256color` table. Definitely can return true for things that aren't present,
// but if it returns false, the item is definitely not present.
#[inline]
const fn could_be_exact_ansi256(r: u8, g: u8, b: u8) -> bool {
    // this bit has a 1 set if the a byte at the given index ever appears in the
    // 256-color table.
    const BITSET_256: [u64; 4] = [
        0x0401004010040101,
        0x0040100481004010,
        0x1004810040100481,
        0x8000401004810040,
    ];
    (BITSET_256[(r / 64) as usize] & (1 << (r % 64))) != 0
        && (BITSET_256[(g / 64) as usize] & (1 << (g % 64))) != 0
        && (BITSET_256[(b / 64) as usize] & (1 << (b % 64))) != 0
}

#[inline]
pub const fn get_exact_color256(r: u8, g: u8, b: u8) -> Option<u8> {
    if !could_be_exact_ansi256(r, g, b) {
        return None;
    }
    if r == g && g == b {
        // greyscale is `(C, C, C)` where C starts at 8, and goes up by 10
        let cm8 = r.wrapping_sub(8);
        if (cm8 <= (0xee - 8)) && (cm8 % 10) == 0 {
            return Some(232 + (cm8 / 10));
        }
    }

    return if let (Some(ri), Some(gi), Some(bi)) = (cvt(r), cvt(g), cvt(b)) {
        Some((ri * 36) + (gi * 6) + bi + 16)
    } else {
        None
    };
    // converts a single component.
    #[inline]
    const fn cvt(n: u8) -> Option<u8> {
        if n == 0 {
            Some(0)
        } else if n > 55 && (n - 55) % 40 == 0 {
            Some((n - 55) / 40)
        } else {
            None
        }
    }
}

#[inline]
const fn could_be_exact_ansi88(r: u8, g: u8, b: u8) -> bool {
    // this isn't particularly information dense...
    const BITSET_88: [u64; 4] = [
        0x400000000001,
        0x8000010000000,
        0x200000400000800,
        0x8000008000012000,
    ];
    (BITSET_88[(r / 64) as usize] & (1 << (r % 64))) != 0
        && (BITSET_88[(g / 64) as usize] & (1 << (g % 64))) != 0
        && (BITSET_88[(b / 64) as usize] & (1 << (b % 64))) != 0
}

#[cfg(feature = "88color")]
pub const fn get_exact_color88(r: u8, g: u8, b: u8) -> Option<u8> {
    #[inline]
    const fn cvt(n: u8) -> Option<u8> {
        match n {
            0 => Some(0),
            139 => Some(1),
            205 => Some(2),
            255 => Some(3),
            _ => None,
        }
    }
    if !could_be_exact_ansi88(r, g, b) {
        return None;
    } else if let (Some(ri), Some(gi), Some(bi)) = (cvt(r), cvt(g), cvt(b)) {
        Some(bi + 4 * gi + 16 * ri + 16)
    } else if r == g && g == b {
        // note: this gets DCEd when called from inside `easychecks88` and such,
        // since it happens after that function checks for greyscale.
        let i = match r {
            0x2e => 0,
            0x5c => 1,
            0x73 => 2,
            0x8b => 3,
            0xa2 => 4,
            0xb9 => 5,
            0xd0 => 6,
            0xe7 => 7,
            _ => return None,
        };
        Some(i + 80)
    } else {
        None
    }
}

#[inline]
pub const fn idx2named(i: u8, packed_tab: &[u8]) -> u8 {
    if i < 16 {
        return i;
    }
    let slot = (i - 16) / 2;
    if (i & 1) != 0 {
        packed_tab[slot as usize] >> 4
    } else {
        packed_tab[slot as usize] & 0xf
    }
}

#[inline]
pub const fn ansi256_to_named(a: u8) -> u8 {
    // TODO: poor info density
    const ANSI256_TO_16: [u8; 120] = [
        0x40, 0x44, 0xcc, 0x62, 0xc6, 0xcc, 0x62, 0x66, 0x88, 0x22, 0x66, 0x76, 0xaa, 0xea, 0xee,
        0xaa, 0xaa, 0xee, 0x51, 0xc5, 0xcc, 0x83, 0xc8, 0xcc, 0x23, 0x86, 0x88, 0x22, 0x66, 0x77,
        0xaa, 0xea, 0xee, 0xaa, 0xaa, 0xee, 0x51, 0x55, 0xcc, 0x83, 0x55, 0xdd, 0x33, 0x88, 0xd8,
        0x33, 0x77, 0x77, 0xaa, 0xea, 0xee, 0xaa, 0xaa, 0xee, 0x51, 0x55, 0xd5, 0x99, 0xdd, 0xdd,
        0x83, 0x88, 0xdd, 0x33, 0x77, 0x77, 0xab, 0x7a, 0x77, 0xaa, 0xaa, 0xee, 0x59, 0xd5, 0xdd,
        0x99, 0xdd, 0xdd, 0x93, 0xd9, 0xdd, 0x3b, 0x77, 0xd7, 0xbb, 0x7b, 0x77, 0xbb, 0xab, 0xff,
        0x99, 0xdd, 0xdd, 0x99, 0xdd, 0xdd, 0x99, 0xd9, 0xdd, 0x7b, 0x77, 0xd7, 0xbb, 0xfb, 0xff,
        0xbb, 0xbb, 0xff, 0x00, 0x00, 0x00, 0x80, 0x88, 0x88, 0x88, 0x78, 0x77, 0x77, 0x77, 0xff,
    ];
    idx2named(a, &ANSI256_TO_16)
}

#[inline]
#[cfg(feature = "88color")]
pub const fn ansi88_to_named(a: u8) -> u8 {
    const ANSI88_TO_16: [u8; 36] = [
        0x40, 0xcc, 0x62, 0x88, 0xaa, 0xee, 0xaa, 0xee, 0x51, 0xcc, 0x83, 0xd8, 0xaa, 0x7e, 0xaa,
        0xee, 0x59, 0xdd, 0x83, 0xdd, 0xbb, 0x77, 0xab, 0xea, 0xd9, 0xdd, 0x99, 0xdd, 0x7b, 0x77,
        0xbb, 0xff, 0x80, 0x88, 0x77, 0xf7,
    ];
    idx2named(a, &ANSI88_TO_16)
}

#[cfg(feature = "88color")]
pub static ANSI256_TO_88: [u8; 240] = [
    16, 17, 17, 18, 18, 19, 20, 21, 22, 22, 23, 23, 20, 21, 21, 22, 22, 23, 24, 25, 25, 26, 27, 43,
    24, 24, 25, 25, 26, 27, 28, 28, 29, 29, 30, 31, 32, 33, 33, 18, 19, 19, 36, 81, 81, 38, 35, 35,
    20, 20, 21, 22, 23, 39, 24, 41, 25, 42, 27, 43, 24, 24, 25, 25, 26, 27, 28, 28, 29, 29, 30, 31,
    32, 33, 33, 34, 34, 35, 36, 82, 49, 50, 35, 39, 36, 36, 37, 38, 38, 39, 40, 41, 41, 42, 43, 43,
    40, 40, 41, 41, 42, 43, 44, 45, 45, 45, 46, 47, 48, 49, 49, 50, 50, 51, 52, 53, 49, 50, 51, 51,
    52, 52, 53, 54, 55, 55, 56, 57, 57, 85, 59, 59, 40, 40, 41, 41, 42, 43, 44, 44, 61, 45, 46, 47,
    48, 65, 49, 50, 50, 51, 64, 53, 65, 66, 67, 67, 52, 68, 53, 70, 54, 55, 72, 73, 73, 74, 75, 55,
    56, 56, 57, 57, 86, 59, 60, 60, 61, 61, 62, 63, 64, 65, 65, 66, 66, 67, 64, 69, 65, 70, 66, 67,
    68, 69, 69, 70, 70, 71, 72, 73, 73, 74, 70, 71, 72, 72, 73, 73, 74, 75, 76, 76, 77, 77, 78, 79,
    16, 16, 80, 80, 80, 80, 80, 81, 81, 81, 82, 82, 37, 37, 37, 84, 84, 85, 85, 58, 86, 86, 87, 87,
];

#[cfg(feature = "88color")]
pub static ANSI88_TO_256: [u8; 72] = [
    16, 18, 20, 21, 28, 30, 32, 33, 40, 42, 44, 45, 46, 48, 50, 51, 88, 90, 92, 93, 100, 245, 104,
    105, 112, 114, 116, 117, 118, 120, 122, 123, 160, 162, 164, 165, 172, 174, 176, 177, 184, 186,
    252, 189, 190, 192, 194, 195, 196, 198, 200, 201, 208, 210, 212, 213, 220, 222, 224, 225, 226,
    228, 230, 231, 236, 59, 243, 245, 247, 250, 252, 254,
];

#[cfg(test)]
mod test {
    use super::*;
    use std::convert::*;
    use std::vec::Vec;

    #[test]
    fn test_exact_color() {
        for (i, &(r, g, b)) in ANSI256_RGB.iter().enumerate() {
            let i = i + 16;
            assert!(could_be_exact_ansi256(r, g, b), "{:?}", (i, r, g, b));
            let n = get_exact_color256(r, g, b)
                .unwrap_or_else(|| panic!("failed to find 256color {}: {:?}", i, (r, g, b)));
            assert_eq!(
                (r, g, b),
                ANSI256_RGB[n.checked_sub(16).unwrap() as usize],
                "wrong 256 @ {}",
                n
            );
            assert_eq!(i, n as usize);
        }
        for (i0, &rgb0) in ANSI256_RGB.iter().enumerate() {
            for (i1, &rgb1) in ANSI256_RGB.iter().enumerate().skip(i0 + 1) {
                assert_ne!(rgb0, rgb1, "{:?}", (i0 + 16, i1 + 16, rgb0, rgb1));
            }
        }
        #[cfg(feature = "88color")]
        for (i, &(r, g, b)) in ANSI88_RGB.iter().enumerate() {
            let i = i + 16;
            assert!(could_be_exact_ansi88(r, g, b), "{:?}", (i, r, g, b));
            let n = get_exact_color88(r, g, b)
                .unwrap_or_else(|| panic!("failed to find 88color {}: {:?}", i, (r, g, b)));
            assert_eq!(
                (r, g, b),
                ANSI88_RGB[n.checked_sub(16).unwrap() as usize],
                "wrong 88 @ {}",
                n
            );
            assert!(n >= 16, "{:?}", (n, i, r, g, b));
            if (r, g, b) != (0x8b, 0x8b, 0x8b) {
                assert_eq!(i, n as usize, "{:?}", (n, i, r, g, b));
            } else {
                // (0x8b, 0x8b, 0x8b) is in the 88 color table two times.
                assert!(
                    (i == 37 || i == 83) && (n == 37 || n == 83),
                    "{:?}",
                    (n, i, r, g, b),
                );
            }
            // Correcness of the above depends on this.
            for (i0, &rgb0) in ANSI88_RGB.iter().enumerate() {
                for (i1, &rgb1) in ANSI88_RGB.iter().enumerate().skip(i0 + 1) {
                    if rgb0 == rgb1 {
                        let i0 = i0 + 16;
                        let i1 = i1 + 16;
                        assert!(i0 == 37 || i0 == 83, "{:?}", (i0, i1, rgb0, rgb1));
                        assert!(i1 == 37 || i1 == 83, "{:?}", (i0, i1, rgb0, rgb1));
                        assert_eq!(rgb0, (0x8b, 0x8b, 0x8b), "{:?}", (i0, i1, rgb0, rgb1));
                    }
                }
            }
        }
    }
    #[test]
    #[ignore]
    fn test_exact_color_exhaustive() {
        use std::collections::BTreeSet;
        let c256 = ANSI256_RGB.iter().copied().collect::<BTreeSet<_>>();
        #[cfg(feature = "88color")]
        let c88 = ANSI88_RGB.iter().copied().collect::<BTreeSet<_>>();
        for r in 0..=255u8 {
            for g in 0..=255u8 {
                for b in 0..=255u8 {
                    let expected256 = if let Some(v) = get_exact_color256(r, g, b) {
                        assert!(v >= 16, "{:?}", (r, g, b, v));
                        assert_eq!(ANSI256_RGB[v as usize - 16], (r, g, b));
                        true
                    } else {
                        false
                    };
                    assert_eq!(expected256, c256.contains(&(r, g, b)), "{:?}", (r, g, b));

                    #[cfg(feature = "88color")]
                    let expected88 = if let Some(v) = get_exact_color88(r, g, b) {
                        assert!(v >= 16, "{:?}", (r, g, b, v));
                        assert_eq!(ANSI88_RGB[v as usize - 16], (r, g, b));
                        true
                    } else {
                        false
                    };
                    #[cfg(feature = "88color")]
                    assert_eq!(expected88, c88.contains(&(r, g, b)), "{:?}", (r, g, b));
                }
            }
        }
    }

    fn gen_colors_256() -> [(u8, u8, u8); 256] {
        let mut colors = [(0, 0, 0); 256];
        // ansi
        colors[..16].copy_from_slice(&ANSI16_TO_RGB);
        // color table
        for r in 0..6usize {
            let rc = if r != 0 { r * 40 + 55 } else { 0 } as u8;
            for g in 0..6usize {
                let gc = if g != 0 { g * 40 + 55 } else { 0 } as u8;
                for b in 0..6usize {
                    let bc = if b != 0 { b * 40 + 55 } else { 0 } as u8;
                    colors[16 + (r * 36) + (g * 6) + b] = (rc, gc, bc);
                }
            }
        }
        // greyscale
        for g in 0..24u8 {
            let gc = g * 10 + 8;
            colors[232 + g as usize] = (gc, gc, gc);
        }
        colors
    }

    #[cfg(feature = "88color")]
    fn gen_colors_88() -> [(u8, u8, u8); 88] {
        let mut colors = [(0, 0, 0); 88];
        // ansi
        colors[..16].copy_from_slice(&ANSI16_TO_RGB);
        // color table
        for r in 0..4usize {
            for g in 0..4usize {
                for b in 0..4usize {
                    let steps = [0, 139, 205, 255];
                    colors[16 + (r * 4 * 4) + (g * 4) + b] = (steps[r], steps[g], steps[b]);
                }
            }
        }
        // greyscale
        for g in 0..8u8 {
            let mut level = (g as f64 * 23.18181818) + 46.36363636;
            if g > 0 {
                level += 23.18181818;
            }
            let gc = if level > 255.0 { 255 } else { level as u8 };
            colors[80 + g as usize] = (gc, gc, gc);
        }
        colors
    }
    #[test]
    fn test_ansi_tables() {
        assert_eq!(&gen_colors_256()[16..], &ANSI256_RGB[..]);
        assert_eq!(&gen_colors_256()[..16], &ANSI16_TO_RGB[..]);
        #[cfg(feature = "88color")]
        {
            assert_eq!(&gen_colors_88()[16..], &ANSI88_RGB[..]);
            assert_eq!(&gen_colors_88()[..16], &ANSI16_TO_RGB[..]);
        }
        // let it = ANSI256_RGB
        //     .iter()
        //     .map(|&(r, g, b)| Lab::from_srgb8(r, g, b)); //.collect::<Vec<_>>();
        // for (l, a, b) in it.map(|c| (c.l, c.a, c.b)) {
        //     std::println!("({}, {}, {}),", l, a, b);
        // }
        for (i, &c) in ANSI256_RGB.iter().enumerate() {
            let lab = Lab::from_srgb8(c.0, c.1, c.2);
            assert_eq!(lab, LAB_PALETTE_ANSI256[i]);
        }
        #[cfg(feature = "88color")]
        {
            let it = ANSI88_RGB.iter().map(|&(r, g, b)| Lab::from_srgb8(r, g, b)); //.collect::<Vec<_>>();
            for (l, a, b) in it.map(|c| (c.l, c.a, c.b)) {
                std::println!("({}, {}, {}),", l, a, b);
            }
            for (i, &c) in ANSI88_RGB.iter().enumerate() {
                let lab = Lab::from_srgb8(c.0, c.1, c.2);
                assert_eq!(lab, LAB_PALETTE_ANSI88[i]);
            }
        }
    }

    #[test]
    fn test_greys() {
        let grey256_nearest = (0..=255u8)
            .map(|i| crate::imp::nearest_ansi256(i, i, i))
            .collect::<Vec<_>>();
        std::eprintln!("nearest grey256: {:?}", grey256_nearest);
        assert_eq!(grey256_nearest, GREY_TO_ANSI256);
        #[cfg(feature = "88color")]
        {
            let grey88_nearest = (0..=255u8)
                .map(|i| crate::imp::nearest_ansi88(i, i, i))
                .collect::<Vec<_>>();
            std::eprintln!("nearest grey88: {:?}", grey88_nearest);
            assert_eq!(grey88_nearest, GREY_TO_ANSI88);
        }
    }

    #[test]
    fn test_idx2named() {
        // our tables used CIEDE2000, which we can't easily verify.
        pub const TO_16_NEAREST: [u8; 120] = [
            0x40, 0x44, 0xcc, 0x62, 0x66, 0xcc, 0x62, 0x66, 0x66, 0x32, 0x66, 0x78, 0xaa, 0xea,
            0xee, 0xaa, 0xea, 0xee, 0x51, 0x55, 0xcc, 0x63, 0x88, 0xcc, 0x83, 0x88, 0x88, 0x33,
            0x88, 0x77, 0xaa, 0x77, 0xee, 0xaa, 0xea, 0xee, 0x51, 0x55, 0xc5, 0x83, 0x88, 0xc8,
            0x83, 0x88, 0x88, 0x33, 0x77, 0x77, 0xaa, 0x77, 0x77, 0xaa, 0xea, 0xee, 0x51, 0x55,
            0xd5, 0x83, 0x88, 0xdd, 0x83, 0x88, 0xd8, 0x73, 0x77, 0x77, 0x7a, 0x77, 0x77, 0xba,
            0xeb, 0xee, 0x99, 0xd9, 0xdd, 0x99, 0xd9, 0xdd, 0x83, 0x77, 0xd7, 0x77, 0x77, 0x77,
            0xbb, 0x77, 0x77, 0xbb, 0xbb, 0xff, 0x99, 0xd9, 0xdd, 0x99, 0xd9, 0xdd, 0x99, 0x77,
            0xd7, 0x77, 0x77, 0x77, 0xbb, 0x77, 0xff, 0xbb, 0xfb, 0xff, 0x00, 0x44, 0x11, 0x61,
            0x86, 0x88, 0x88, 0x88, 0x77, 0x77, 0x77, 0xff,
        ];
        use crate::imp::lab::Lab;
        let lab16 = ANSI16_TO_RGB
            .iter()
            .map(|&(r, g, b)| Lab::from_srgb8(r, g, b))
            .collect::<Vec<_>>();
        let bytes = ANSI256_RGB
            .iter()
            .map(|&(r, g, b)| {
                crate::imp::fallback::nearest_impl(Lab::from_srgb8(r, g, b), &lab16)
                    .checked_sub(16)
                    .unwrap()
                    .try_into()
                    .unwrap()
            })
            .collect::<Vec<u8>>();
        // print it out in case we actually do want to replace it.
        dump_tab("TO_16_NEAREST", &pack_16tab(&bytes));
        for (i, &(r, g, b)) in ANSI256_RGB.iter().enumerate() {
            let expect = idx2named((i + 16).try_into().unwrap(), &TO_16_NEAREST);
            assert!(expect <= 0xf);
            let found: u8 = crate::imp::fallback::nearest_impl(Lab::from_srgb8(r, g, b), &lab16)
                .checked_sub(16)
                .unwrap()
                .try_into()
                .unwrap();
            assert_eq!(found, expect, "{:?}", (i, r, g, b, expect, found));
        }
    }

    fn pack_16tab(t: &[u8]) -> std::vec::Vec<u8> {
        let mut r = std::vec![0u8; t.len() / 2];
        assert_eq!(r.len() * 2, t.len());
        for i in 0..r.len() {
            let a = t[i * 2];
            let b = t[i * 2 + 1];
            assert!(a < 16 && b < 16);
            r[i] = a | (b << 4)
        }
        r
    }

    fn dump_tab(name: &str, data: &[u8]) {
        std::eprintln!("{}", tab2string(name, data));
    }

    fn tab2string(name: &str, data: &[u8]) -> std::string::String {
        use core::fmt::Write;
        let hex = true;
        let mut s = std::string::String::new();
        let _ = write!(s, "pub const {}: [u8; {}] = [", name, data.len(),);
        for line in data.chunks(10) {
            let _ = s.push_str("\n   ");
            for &i in line {
                if hex {
                    let _ = write!(s, " 0x{:02x},", i);
                } else {
                    let _ = write!(s, " {},", i);
                }
            }
        }
        // let x = 0x124444;
        s.push_str("\n];");
        // w.write_all(s);
        // eprintln!("{}", s);
        s
    }
}
